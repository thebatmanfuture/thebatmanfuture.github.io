##### 1.为什么每个应用都有自己独立的4GB内存空间？

归根结底是因为寻址宽度是8位

======================================================================

那么最大可以表示的范围就是0 - FFFFFFFF

也就是可以表示FFFFFFFF + 1个字节，如果是字，那就要 * 8，得到8 0000 0000，转换为10进制

34359738369

再除以8，表示可以最大表示多少个字节 => 4294967296 B

再除以1024，表示可以最大表示多少个KB => 4194304KB

再除以1024，表示可以最大表示多少个MB => 4096MB

再除以1024，表示可以最大表示多少个GB => 4GB

##### 2.movs指令和mov指令的区别

movs指令可以实现从内存到内存，且每次执行完edi和esi的值都会加一，而mov不可以

~~~
movs byte ptr es:[edi],byte ptr ds:[esi]
movsb
~~~

##### 3.标志寄存器EFL是什么，有什么作用？

~~~
如果DF位为0，则执行完movsb指令后esi和edi会加1，反之
如果DF位为1，则执行完movsb指令后esi和edi会减1
~~~

##### 4.rep指令是什么？

~~~
mov ecx,10
rep movsd
~~~

令ecx为10（16进制），也就是10进制的16

rep movsd就是执行ecx次，也就是执行16次，每执行完一次就减一



##### 5.stos指令是什么？

将al/ax/eax的值存储到[edi]指定的内存单元

##### 6.ESP寄存器有什么特别的？

 栈指针寄存器，存储了当前的堆栈用到哪里了

这里在堆栈中，比这个esp所存储值大的地址表示已经被用过了，小的则没用用过

执行完指令之后最好修改esp



##### 7.push指令是什么？

push 1

就是将1入栈，且令esp + 4（dword）

pop eax

就是出栈，将栈顶的值赋值给eax寄存器，然后令esp + 4（dword）

##### 8.EIP指令是什么？

~~~
EIP寄存器存储的是CPU下一次要执行的地址
这个所存储的是什么，CPU下一次就会找这个地址

可以通过jmp指令修改
~~~



##### 9.jmp指令和call指令的区别？

遇见call就需要按F7

~~~
call指令执行之后除了会像jmp一样修改eip的值，还会把call指令的下一个指令压在堆栈中，这样esp也会减4
~~~



##### 10.ret指令是什么？

~~~
该指令把当前栈顶里的值放在了EIP，同时栈顶指针+4，esp+4
~~~





##### 11.反调试之fake F8

让F8失效，F7和F8只有在call指令时才有区别

调试器原理：

断点：0xCC

单步步入：设置EFLAGS的TF位

单步步过：在下一次设置断点

如果遇到int 3调试就会停下来
























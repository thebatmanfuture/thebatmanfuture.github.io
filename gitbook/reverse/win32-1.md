静态库文件没有入口

![](https://s3.bmp.ovh/imgs/2023/03/18/3b27b0ae665304b2.png)

![](https://s3.bmp.ovh/imgs/2023/03/18/651f87407b04eeea.png)

~~~
编译器CL.EXE
链接器LINK.EXE
相当于linux下的GCC
~~~

~~~
三个主要的windows库
~~~

![](https://s3.bmp.ovh/imgs/2023/03/18/a3c2966207a451b5.png)

![](https://s3.bmp.ovh/imgs/2023/03/18/82fc36716517b968.png)

~~~
windows.h包含了很多头文件，所以只要#include windows.h这一个就可以了
~~~



#### 相关函数

![](https://s3.bmp.ovh/imgs/2023/03/18/126de413e4e5bac6.png)

~~~
HINSTANCE是找当前进程内存
HWND是找窗口数据
~~~

MessageBox是阻塞函数，一旦执行可能不立即返回

~~~c++
//利用模板提供通用的交换函数
#include <stdlib.h>
#include <windows.h>

int WinMain(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, int nCmdShow) {
	int nRet = MessageBoxA(NULL, "batmanfuture", "edusrc", MB_YESNOCANCEL|MB_ICONERROR);
	if (nRet == IDYES) {

	}
	else if(nRet == IDNO){

	}
	else {

	}
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/18/061b4a84eeed6278.png)

![](https://s3.bmp.ovh/imgs/2023/03/18/cf08a277c2b04e01.png)

.

第一个windows窗口

![](https://s3.bmp.ovh/imgs/2023/03/18/cf518e05ef250441.png)



~~~c++
#include <windows.h>

// 定义窗口类名
const char g_szClassName[] = "myWindowClass";

// 窗口过程函数
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_CLOSE:
        DestroyWindow(hwnd);
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow)
{
    // 注册窗口类
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = g_szClassName;
    RegisterClassEx(&wc);

    // 创建窗口
    HWND hwnd = CreateWindowEx(
        0,
        g_szClassName,
        "My Window",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 500, 500,
        NULL, NULL, hInstance, NULL);

    if (hwnd == NULL)
    {
        MessageBox(NULL, "窗口创建失败！", "Error", MB_ICONERROR);
        return 0;
    }

    // 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // 消息循环
    MSG Msg;
    while (GetMessage(&Msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }

    return Msg.wParam;
}
~~~

~~~
    HWND hChild1 = CreateWindowEx(
            0,
            "Child",
            "c1",
            WS_CHILD| WS_VISIBLE|WS_OVERLAPPEDWINDOW,
            0, 0, 500, 500,
            hwnd, NULL, hInstance, NULL);
    HWND hChild2 = CreateWindowEx(
            0,
            "Child",
            "c1",
            WS_CHILD| WS_VISIBLE|WS_OVERLAPPEDWINDOW,
            0, 0, 200, 300,
            hwnd, NULL, hInstance, NULL);
~~~



![208dfcb97f9e21056162f21a14e29861.png](https://s1.imagehub.cc/images/2023/03/18/208dfcb97f9e21056162f21a14e29861.png)

#### 宽字节

![](https://s3.bmp.ovh/imgs/2023/03/18/6e3e3eda143c65a3.png)

~~~c++
//利用模板提供通用的交换函数
#include <stdlib.h>
#include <iostream>
#include <windows.h>
#include <stdio.h>

void W_char() {
	const wchar_t* pszText = L"Hello, 世界！";
	int len = wcslen(pszText);
	wprintf(L"%s %d\n",pszText, len);

}

int main() {

	W_char();
	getchar();

	return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/18/0602d58fac848011.png)

.

#### 注册窗口类

窗口类就是一个包含了窗口的各种参数的结构体

每个窗口都有窗口类，基于窗口类创建窗口

![](https://s3.bmp.ovh/imgs/2023/03/18/ac3c40090cbcdd6e.png)

系统窗口类，不需要注册，系统已经注册好的

比如：按钮- BUTTON 编辑框 -EDIT

这里可以不用自定义的窗口类，可以用系统自带的Button

![](https://s3.bmp.ovh/imgs/2023/03/18/cdcfcf5fcd3d6d1a.png)

##### 全局和局部窗口类

利用RegisterClass类将我们定义的窗口类写入到内核中

![](https://s3.bmp.ovh/imgs/2023/03/18/df9343e3afeeb4ab.png)

![](https://s3.bmp.ovh/imgs/2023/03/18/fe257bcbc87d04e9.png)

想要注册窗口类(WNDCLASS)需要哪些参数

~~~c++
    WNDCLASS wc = { 0 };
    wc.cbClsExtra = 0;//申请两种不同的缓冲区
    wc.cbWndExtra = 0;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hCursor = NULL;
    wc.hIcon = NULL;
    wc.hInstance = hIns;
    wc.lpfnWndProc = WndProc;
    wc.lpszClassName = "Main";
    wc.lpszMenuName = NULL;
    wc.style = CS_HREDRAW | CS_VREDRAW;

    RegisterClass(&wc); //将以上赋值内容写入操作系统
~~~

![](https://s3.bmp.ovh/imgs/2023/03/18/03946ac46a7c11c6.png)

1）style

2）lpfnWndProc

需要将上面定义的窗口处理函数拿过来

![](https://s3.bmp.ovh/imgs/2023/03/18/d294366adb3c4441.png)

3）cbClsExtra 和 cbWndExtra

cbClsExtra 窗口类附加数据缓冲区要申请多少字节

cbWndExtra 窗口数据附加缓冲区要申请多少字节

=======================================================================================

![](https://s3.bmp.ovh/imgs/2023/03/18/c3b2895206b62646.png)

创建窗口

![](https://s3.bmp.ovh/imgs/2023/03/18/b79fceb05e9b4466.png)



hIns的主要目的就是确定是不是一个基于本进程注册的局部窗口类去创建窗口，如果基于全局窗口和系统窗口则这个参数无用

![](https://s3.bmp.ovh/imgs/2023/03/18/bc6d2a529696b307.png)

![](https://s3.bmp.ovh/imgs/2023/03/18/41b8e66816fb2f2e.png)

##### 创建子窗口

。。

![839bc589db6f29f987f6f9da2eef37a5.png](https://s1.imagehub.cc/images/2023/03/18/839bc589db6f29f987f6f9da2eef37a5.png)

在消息中，存在6个参数，我们使用GetMessage去抓取消息时也需要传入6个参数

![4ba2ce46abda08fa4af8f7fd66c083fc.png](https://s1.imagehub.cc/images/2023/03/18/4ba2ce46abda08fa4af8f7fd66c083fc.png)

这里我们第一个参数Msg是一个结构体跟进去

第一个hwnd就是窗口的句柄，message消息的id，wParam|lParam消息的两个参数，time产生时间，

![d545a06d2ebeba44b291c93ae629b47d.png](https://s1.imagehub.cc/images/2023/03/18/d545a06d2ebeba44b291c93ae629b47d.png)

![64c16acdc1b23d9d6e4a0f0547b2677d.png](https://s1.imagehub.cc/images/2023/03/18/64c16acdc1b23d9d6e4a0f0547b2677d.png)

GetMessage抓取消息，DispatchMessage处理消息，调用WndProc函数

然后是GetMessage函数![eb713bab2643a2f47317f77de0a849c6.png](https://s1.imagehub.cc/images/2023/03/18/eb713bab2643a2f47317f77de0a849c6.png)

![3521b53f89ebfefb43dde5d3752f4aa1.png](https://s1.imagehub.cc/images/2023/03/18/3521b53f89ebfefb43dde5d3752f4aa1.png)

~~~
这里第二个参数，如果窗口句柄为NULL，则表示当前进程的哪个窗口都抓
第三个和第四个参数表示抓取的窗口id范围，如果都是0则表示哪个窗口都抓
~~~

这里我们在while循环中，如果不为0则我们的消息会一直循环，窗口无法关闭，只有当GetMessage为0时才会停止

![23ef751a04d837ec987ec0be281d704d.png](https://s1.imagehub.cc/images/2023/03/18/23ef751a04d837ec987ec0be281d704d.png)

在手册中显示，只有当函数检索到WM_QUIT时，返回值才会为0

![3a2213a2721de8f8948b7415b4d76bfc.png](https://s1.imagehub.cc/images/2023/03/18/3a2213a2721de8f8948b7415b4d76bfc.png)

所以我们的PostQuitMessage函数其实是抛出了一个WM_QUIT使得GetMessage能够抓到导致返回0

![40a39ab92c4f1fc1a2af2bc05b2db536.png](https://s1.imagehub.cc/images/2023/03/18/40a39ab92c4f1fc1a2af2bc05b2db536.png)

![a7099bdd31d1ff26a081b9bda0308ae3.png](https://s1.imagehub.cc/images/2023/03/18/a7099bdd31d1ff26a081b9bda0308ae3.png)

TranslateMessage函数是将虚拟键消息转换为字符消息

~~~
返回值

如果消息被翻译（即，字符消息被发布到线程的消息队列），返回值不为零。

如果消息未被翻译（即，一个字符消息没有发布到线程的消息队列），返回值为零。
~~~

比如我们的键盘摁下a，如果没有开启CapsLock则表示小写，开启则表示大写，所以需要翻译，所以下面就是判断是不是键盘消息，如果是则翻译，不是则return返回派发进行DispatchMessage

![93f2f223695de741669f09f41519b9a4.png](https://s1.imagehub.cc/images/2023/03/18/93f2f223695de741669f09f41519b9a4.png)

#### 常见消息

![58a81133d3c7dbf7360600dd543a8edd.png](https://s1.imagehub.cc/images/2023/03/18/58a81133d3c7dbf7360600dd543a8edd.png)

1）WM_DESTROY

![831e36b52df02ffef33ce6b0a11ae851.png](https://s1.imagehub.cc/images/2023/03/18/831e36b52df02ffef33ce6b0a11ae851.png)

![f77b154ff70c4000fa13fb83328fd3b3.png](https://s1.imagehub.cc/images/2023/03/18/f77b154ff70c4000fa13fb83328fd3b3.png)

2）WM_SYSCOMMAND（点击关闭或者其他地方时产生的消息）

![b47dec2ba27bc8460fc965d384b4fbd3.png](https://s1.imagehub.cc/images/2023/03/18/b47dec2ba27bc8460fc965d384b4fbd3.png)

![35cf647941cd98e50c4c15d0003e7f0a.png](https://s1.imagehub.cc/images/2023/03/18/35cf647941cd98e50c4c15d0003e7f0a.png)



##### 修改版

当我们打开上图之后点击右上角的X想关闭程序时，我们这里程序执行的流程是

先执行WM_SYSCOMMAND，因为没有return 0，执行default的DefWindowProc函数，销毁窗口，产生case WM_DESTROY，调用PostQuitMessage函数，在程序中抛出了一个WM_QUIT消息使得GetMessage能够抓到导致返回0，使得进程结束；

而如果写return 0了，则不会执行default...

![93c7e1eaa452a444fd44a18feb2b42c8.png](https://s1.imagehub.cc/images/2023/03/18/93c7e1eaa452a444fd44a18feb2b42c8.png)

但是我们写完MessageBox函数后，点击最大化和最小化按钮都会弹出对话框，需要设定是通过关闭窗口执行弹窗

~~~c++
        case WM_SYSCOMMAND:
            if(wParam == SC_CLOSE){
                int nRet = MessageBox(hwnd, "是否退出", "Infor", MB_YESNO);
                if(nRet == IDYES){
                    // 什么也不写执行default 销毁窗口，然后调用case WM_DESTROY
                    // 里的PostQuitMessage函数向进程插入WM_QUIT消息导致进行结束
                }else{
                    // 如果程序不想关闭则return任意值，只要不执行DefWindowProc函数
                    return 0;
                }
            }
~~~

![8b9b7474e3d56298256697247e04429a.png](https://s1.imagehub.cc/images/2023/03/18/8b9b7474e3d56298256697247e04429a.png)

3）WM_CREATE

![9dbb65e3d3fc5c4417ad0bead5205a21.png](https://s1.imagehub.cc/images/2023/03/18/9dbb65e3d3fc5c4417ad0bead5205a21.png)

这里我们自己编写的函数OnCreate的接收的第二个返回值lParam可以拿到窗口创建时的12个参数，这里的第12个参数是附加参数

![bca54caf70afb277dcc402d89581731a.png](https://s1.imagehub.cc/images/2023/03/18/bca54caf70afb277dcc402d89581731a.png)

~~~c++
#include <windows.h>

// 定义窗口类名
const char g_szClassName[] = "myWindowClass";

void OnCreate(HWND hwnd,LPARAM lParam){
    CREATESTRUCT *pcs = (CREATESTRUCT*)lParam;
    char* pszText = pcs->lpCreateParams;
    MessageBox(NULL, pszText, "123", MB_OK);

}


// 窗口过程函数
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CREATE:
            OnCreate(hwnd, lParam);
            break;
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        case WM_SYSCOMMAND:
            if(wParam == SC_CLOSE){
                int nRet = MessageBox(hwnd, "是否退出", "Infor", MB_YESNO);
                if(nRet == IDYES){
                    // 什么也不写执行default 销毁窗口，然后调用case WM_DESTROY
                    // 里的PostQuitMessage函数向进程插入WM_QUIT消息导致进行结束
                }else{
                    // 如果程序不想关闭则return任意值，只要不执行DefWindowProc函数
                    return 0;
                }
            }
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow)
{
    // 注册窗口类
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = g_szClassName;
    RegisterClassEx(&wc);

    // 创建窗口
    HWND hwnd = CreateWindowEx(
            0,
            g_szClassName,
            "My Window",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 500, 500,
            NULL, NULL, hInstance, "hello world");

    if (hwnd == NULL)
    {
        MessageBox(NULL, "窗口创建失败！", "Error", MB_ICONERROR);
        return 0;
    }


    // 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // 消息循环
    MSG Msg;
    while (GetMessage(&Msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }

    return Msg.wParam;
}
~~~

WS_SIZE

打开窗口时窗口大小有变化，点击最大最小化，双击标题栏

![](https://s3.bmp.ovh/imgs/2023/03/19/d10173e7aad2de41.png)



#### 消息循环的原理

![](https://s3.bmp.ovh/imgs/2023/03/19/982cedad21dadc7c.png)

如果程序被阻塞，则不参与cpu的调度

~~~c++
#include <windows.h>
HANDLE g_hOutput = 0;   //标准输出句柄
// 定义窗口类名
const char g_szClassName[] = "myWindowClass";

void OnCreate(HWND hwnd,LPARAM lParam){
    CREATESTRUCT *pcs = (CREATESTRUCT*)lParam;
    char* pszText = pcs->lpCreateParams;
    MessageBox(NULL, pszText, "123", MB_OK);

}


// 窗口过程函数
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CREATE:
            OnCreate(hwnd, lParam);
            break;
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        case WM_SYSCOMMAND:
            if(wParam == SC_CLOSE){
                int nRet = MessageBox(hwnd, "是否退出", "Infor", MB_YESNO);
                if(nRet == IDYES){
                    // 什么也不写执行default 销毁窗口，然后调用case WM_DESTROY
                    // 里的PostQuitMessage函数向进程插入WM_QUIT消息导致进行结束
                }else{
                    // 如果程序不想关闭则return任意值，只要不执行DefWindowProc函数
                    return 0;
                }
            }
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow)
{
    g_hOutput = GetStdHandle(STD_OUTPUT_HANDLE);

    // 注册窗口类
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = g_szClassName;
    RegisterClassEx(&wc);

    // 创建窗口
    HWND hwnd = CreateWindowEx(
            0,
            g_szClassName,
            "My Window",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 500, 500,
            NULL, NULL, hInstance, "hello world");

    if (hwnd == NULL)
    {
        MessageBox(NULL, "窗口创建失败！", "Error", MB_ICONERROR);
        return 0;
    }


    // 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // 消息循环
    MSG Msg;
//    while (GetMessage(&Msg, NULL, 0, 0) > 0)
//    {
//        TranslateMessage(&Msg);
//        DispatchMessage(&Msg);
//    }
    while(1){
        if(PeekMessage(&Msg, NULL, 0, 0, PM_NOREMOVE)){
            //有消息
            if(GetMessage(&Msg, NULL, 0, 0)){
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }else{
                return 0;
            }
        }else{
            //没消息-空闲处理
            WriteConsole(g_hOutput, "OnIdle", strlen("OnIdle"), NULL, NULL);

        }
    }


    return Msg.wParam;
}
~~~

![480efda0aeb477e130b177f39a88ce86.png](https://s1.imagehub.cc/images/2023/03/19/480efda0aeb477e130b177f39a88ce86.png)

当没有消息时，屏幕打印OnIdle，说明此时很闲



##### 发生消息

![](https://s3.bmp.ovh/imgs/2023/03/19/f05ad7683cf1a1bc.png)

PostQuitMessage函数也是调用SendMessage或者PostMessage函数这两个消息的其中一个

为了验证是哪一个，我们注释掉PostQuitMessage函数，先调用SendMessage消息，如果关闭窗口进程结束说明PostQuitMessage调的是此，如果关闭窗口进程不结束则说明是PostMessage



SendMessage：

![](https://s3.bmp.ovh/imgs/2023/03/19/2cdb1257558401d9.png)

PostMessage：

![](https://s3.bmp.ovh/imgs/2023/03/19/f8d625a33322104c.png)

##### 消息分类

![](https://s3.bmp.ovh/imgs/2023/03/19/114a540f6dfbbfea.png)

操作系统定制好的，只负责发送或者处理；

如果是自定义消息则需要用户自己发送和处理

~~~c++
//	#define WM_MMYMESSAGE 0x400 + 100;
#define WM_MMYMESSAGE WM_USER + 1001;
~~~

这里为什么写的是WM_USER而不是0x400呢？因为

![](https://s3.bmp.ovh/imgs/2023/03/19/ca847782dfba0000.png)

使得我们消息的地址在自定义消息范围内

再使用PostMessage发送消息

![](https://s3.bmp.ovh/imgs/2023/03/19/72930d98fee80612.png)

自定制消息

![](https://s3.bmp.ovh/imgs/2023/03/19/91d0be1a9a6c62c1.png)

~~~c++
#include <windows.h>
#define WM_MMYMESSAGE WM_USER + 1001
HANDLE g_hOutput = 0;   //标准输出句柄
// 定义窗口类名
const char g_szClassName[] = "myWindowClass";

void OnCreate(HWND hwnd,LPARAM lParam){
    CREATESTRUCT *pcs = (CREATESTRUCT*)lParam;
    char* pszText = pcs->lpCreateParams;
    MessageBox(NULL, pszText, "123", MB_OK);

    PostMessage(hwnd, WM_MMYMESSAGE,1,2);

}
void OnMyMessage(HWND hwnd, WPARAM wparam, LPARAM lparam){
    char szText[256] = {0};
    MessageBox(hwnd, szText, "infor",MB_OK);
}

// 窗口过程函数
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_MMYMESSAGE:
            OnMyMessage(hwnd, wParam,lParam);
            break;

        case WM_CREATE:
            OnCreate(hwnd, lParam);
            break;
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            //PostQuitMessage(0);

            PostMessage(hwnd, WM_QUIT,0,0);
            break;
        case WM_SYSCOMMAND:
            if(wParam == SC_CLOSE){
                int nRet = MessageBox(hwnd, "是否退出", "Infor", MB_YESNO);
                if(nRet == IDYES){
                    // 什么也不写执行default 销毁窗口，然后调用case WM_DESTROY
                    // 里的PostQuitMessage函数向进程插入WM_QUIT消息导致进行结束
                }else{
                    // 如果程序不想关闭则return任意值，只要不执行DefWindowProc函数
                    return 0;
                }
            }
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow)
{
    g_hOutput = GetStdHandle(STD_OUTPUT_HANDLE);

    // 注册窗口类
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = g_szClassName;
    RegisterClassEx(&wc);

    // 创建窗口
    HWND hwnd = CreateWindowEx(
            0,
            g_szClassName,
            "My Window",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 500, 500,
            NULL, NULL, hInstance, "hello world");

    if (hwnd == NULL)
    {
        MessageBox(NULL, "窗口创建失败！", "Error", MB_ICONERROR);
        return 0;
    }


    // 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // 消息循环
    MSG Msg;
//    while (GetMessage(&Msg, NULL, 0, 0) > 0)
//    {
//        TranslateMessage(&Msg);
//        DispatchMessage(&Msg);
//    }
    while(1){
        if(PeekMessage(&Msg, NULL, 0, 0, PM_NOREMOVE)){
            //有消息
            if(GetMessage(&Msg, NULL, 0, 0)){
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }else{
                return 0;
            }
        }else{
            //没消息-空闲处理
            WriteConsole(g_hOutput, "OnIdle", strlen("OnIdle"), NULL, NULL);

        }
    }


    return Msg.wParam;
}
~~~



#### 消息队列

~~~
消息队列是用来存放消息的队列
消息在队列中是先进先出
所有窗口程序都具有消息队列
程序可以从队列中获取消息
~~~

只有GetMessage到本进程的队列里抓消息，它也只会抓消息。

![](https://s3.bmp.ovh/imgs/2023/03/19/9fb609b15b1fcb3c.png)



~~~
操作系统拿到第一个消息的窗口句柄
找到保存窗口数据的内存
通过内存，当前程序实例句柄(hIns)

~~~

![](https://s3.bmp.ovh/imgs/2023/03/19/c734afbe1ea8cbea.png)

PostMessage造的消息 -> 系统队列

SendMessage造的消息 -> 内部直接调用窗口处理函数![](https://s3.bmp.ovh/imgs/2023/03/19/d874dcc2e9e7e43f.png)

一个消息本身没有队列和非队列的属性，如果进队列则是队列消息；不进队列就是非队列消息

~~~
必须进队列的消息：WM_QUIT，如果不进队列，那么GetMessage无法抓得到，程序也无法关闭
必须不进队列的消息：WM_CREATE，窗口创建成功后显示前
~~~

![](https://s3.bmp.ovh/imgs/2023/03/19/f43f8ca5657be3a7.png)

~~~
这里的第二条，是GetMessage如果发现本进程不存在消息，则会质问操作系统索取消息，操作系统则会将消息转发给程序消息队列，供给GetMessage去抓取消息
~~~

WM_PAINT

![](https://s3.bmp.ovh/imgs/2023/03/19/05eb19e9f5d43747.png)

也就是说GetMessage有消息可抓，就不会检查WM_PAINT查看窗口是否需要绘制。

![](https://s3.bmp.ovh/imgs/2023/03/19/e4915f1437a86ffe.png)

~~~c++
#include <windows.h>
#define WM_MMYMESSAGE WM_USER + 1001
HANDLE g_hOutput = 0;   //标准输出句柄
// 定义窗口类名
const char g_szClassName[] = "myWindowClass";

void OnCreate(HWND hwnd,LPARAM lParam){
    CREATESTRUCT *pcs = (CREATESTRUCT*)lParam;
    char* pszText = pcs->lpCreateParams;
    MessageBox(NULL, pszText, "123", MB_OK);

    PostMessage(hwnd, WM_MMYMESSAGE,1,2);

}
void OnMyMessage(HWND hwnd, WPARAM wparam, LPARAM lparam){
    char szText[256] = {0};
    MessageBox(hwnd, szText, "infor",MB_OK);
}

void OnPaint(HWND hwnd){
    char* pszText = "WM_PAINT\n";
    WriteConsole(g_hOutput, pszText, strlen(pszText),NULL, NULL);
}

// 窗口过程函数
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_PAINT:
            OnPaint(hwnd);

        case WM_MMYMESSAGE:
            OnMyMessage(hwnd, wParam,lParam);
            break;

        case WM_CREATE:
            OnCreate(hwnd, lParam);
            break;
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            //PostQuitMessage(0);

            PostMessage(hwnd, WM_QUIT,0,0);
            break;
        case WM_SYSCOMMAND:
            if(wParam == SC_CLOSE){
                int nRet = MessageBox(hwnd, "是否退出", "Infor", MB_YESNO);
                if(nRet == IDYES){
                    // 什么也不写执行default 销毁窗口，然后调用case WM_DESTROY
                    // 里的PostQuitMessage函数向进程插入WM_QUIT消息导致进行结束
                }else{
                    // 如果程序不想关闭则return任意值，只要不执行DefWindowProc函数
                    return 0;
                }
            }
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow)
{
    AllocConsole();
    g_hOutput = GetStdHandle(STD_OUTPUT_HANDLE);

    // 注册窗口类
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = g_szClassName;
    RegisterClassEx(&wc);

    // 创建窗口
    HWND hwnd = CreateWindowEx(
            0,
            g_szClassName,
            "My Window",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 500, 500,
            NULL, NULL, hInstance, "hello world");

    if (hwnd == NULL)
    {
        MessageBox(NULL, "窗口创建失败！", "Error", MB_ICONERROR);
        return 0;
    }


    // 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // 消息循环
    MSG Msg;
//    while (GetMessage(&Msg, NULL, 0, 0) > 0)
//    {
//        TranslateMessage(&Msg);
//        DispatchMessage(&Msg);
//    }
    while(1){
        if(PeekMessage(&Msg, NULL, 0, 0, PM_NOREMOVE)){
            //有消息
            if(GetMessage(&Msg, NULL, 0, 0)){
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }else{
                return 0;
            }
        }else{
            //没消息-空闲处理
            WriteConsole(g_hOutput, "OnIdle", strlen("OnIdle"), NULL, NULL);

        }
    }


    return Msg.wParam;
}
~~~

窗口从创建成功到第一次绘制，是ShowWindow函数，其余是GetMessage函数发送的



#### 键盘消息

![](https://s3.bmp.ovh/imgs/2023/03/19/2edb6e5d415a2dc5.png)

~~~
#include <windows.h>

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    // 注册窗口类
    const char CLASS_NAME[] = "My Window Class";
    WNDCLASS wc = {};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    RegisterClass(&wc);

    // 创建窗口
    HWND hwnd = CreateWindowEx(
            0,
            CLASS_NAME,
            "Win32 WM_KEYDOWN/WM_KEYUP Example",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 640, 480,
            NULL,
            NULL,
            hInstance,
            NULL
    );

    if (hwnd == NULL)
    {
        return 0;
    }

    // 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // 消息循环
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        WPARAM VK_A;
        case WM_KEYDOWN:
            // 按下键盘上的按键
            switch (wParam)
            {
                case VK_A:
                    MessageBox(hwnd, "You pressed 'A' key!", "Key Pressed", MB_OK);
                    break;
            }
            break;

        case WM_KEYUP:
            // 释放键盘上的按键
            switch (wParam)
            {
                case VK_A:
                    MessageBox(hwnd, "'A' key is released!", "Key Released", MB_OK);
                    break;
            }
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 0;
}
~~~

##### 字符消息

![](https://s3.bmp.ovh/imgs/2023/03/19/b5210827c8069128.png)![](https://s3.bmp.ovh/imgs/2023/03/19/7b81d9f5a9622ab8.png)

.

#### 鼠标消息

![](https://s3.bmp.ovh/imgs/2023/03/19/74e4ec7c5c20d31b.png)

![](https://s3.bmp.ovh/imgs/2023/03/19/bc856677499676e7.png)

#### 定时器消息

![4371e5fb124a0711571403f05f2176b8.png](https://s1.imagehub.cc/images/2023/03/19/4371e5fb124a0711571403f05f2176b8.png)

![b09b6e83a17dcc177570daa74f8c7893.png](https://s1.imagehub.cc/images/2023/03/19/b09b6e83a17dcc177570daa74f8c7893.png)



#### 菜单资源

右键菜单是弹出式菜单

点击顶层菜单下拉出来的也是弹出式菜单

鼠标放在图标上也有菜单就是系统菜单

![2c6a9597d6f358e6decf84bc98ba298e.png](https://s1.imagehub.cc/images/2023/03/19/2c6a9597d6f358e6decf84bc98ba298e.png)

菜单其实是容器的作用

![c1c8c4cdeeb6d567987d1c19c73afa54.png](https://s1.imagehub.cc/images/2023/03/19/c1c8c4cdeeb6d567987d1c19c73afa54.png)



===========================================

#### 静态库

~~~
运行不存在

静态库源码被链接到调用程序中

目标程序的归档
~~~

![3ec7f11e00cf1b2e8bf290a7d6fcced9.png](https://s1.imagehub.cc/images/2023/03/19/3ec7f11e00cf1b2e8bf290a7d6fcced9.png)

#### 动态库

~~~
1)运行时独立存在
2)源码不会链接到执行程序
3)使用时加载(使用动态库必须动态库执行)
~~~

![9f1bec9dd30f3e82e0341cfde932b553.png](https://s1.imagehub.cc/images/2023/03/19/9f1bec9dd30f3e82e0341cfde932b553.png)

Lib是作为动态库函数映射使用

![ff4b4c8d5a219b924538f84fb3f06269.png](https://s1.imagehub.cc/images/2023/03/19/ff4b4c8d5a219b924538f84fb3f06269.png)



![8402e3e731d65846c57346aba8df8373.png](https://s1.imagehub.cc/images/2023/03/19/8402e3e731d65846c57346aba8df8373.png)

##### 动态库的使用

![20ffdacdbc6785d1e8ead43cf6f2fc71.png](https://s1.imagehub.cc/images/2023/03/19/20ffdacdbc6785d1e8ead43cf6f2fc71.png)![34134a72d96284e834dfba82cf7088b9.png](https://s1.imagehub.cc/images/2023/03/19/34134a72d96284e834dfba82cf7088b9.png)

本来连接器在lib中是抓源码，但是发现lib中没有源码，所以抓编号（从lib->dll）和dll文件名

流程：

![16f68e4bd1a4ff64ab59a0705cda8d97.png](https://s1.imagehub.cc/images/2023/03/19/16f68e4bd1a4ff64ab59a0705cda8d97.png)

#### 线程

cpu是以线程为单位调度的；进程开启意味着分内存，线程开启意味着执行

![13d6ddbcd7fbd476ef33bb38285161a2.png](https://s1.imagehub.cc/images/2023/03/19/13d6ddbcd7fbd476ef33bb38285161a2.png)

主线程只有一个

##### 创建线程

![2b39eba6ff475947ae63ddccaaf9ee8b.png](https://s1.imagehub.cc/images/2023/03/19/2b39eba6ff475947ae63ddccaaf9ee8b.png)

凡是看到安全属性这种地方，都可以为空

窗口处理函数和线程处理函数是自己定义后供操作系统调用

~~~c++
#include <windows.h>
#include "stdio.h"

DWORD CALLBACK TestProc(LPVOID pParam){
    char * pszText = (char *)pParam;

    while(1){
        printf("%s\n", pszText);
        Sleep(1000);
    }
}


int main(){

    DWORD nID = 0;
    char * pszText = "********";
    CreateThread(NULL, 0, TestProc, pszText, 0,&nID);   //最后一个0就是立即启动
    //如果想让子线程执行，就不能让主线程结束
    getchar();

    return 0;
}
~~~

![1db12744aaa40b14aa88cc19554c52b8.png](https://s1.imagehub.cc/images/2023/03/19/1db12744aaa40b14aa88cc19554c52b8.png)

唤醒和挂起

唤醒

~~~c++
#include <windows.h>
#include "stdio.h"

DWORD CALLBACK TestProc(LPVOID pParam){
    char * pszText = (char *)pParam;

    while(1){
        printf("%s\n", pszText);
        Sleep(1000);
    }
}


int main(){

    DWORD nID = 0;
    char * pszText = "********";
    // 这里是CREATE_SUSPENDED就是挂起，是0就是立即执行
    CreateThread(NULL, 0, TestProc, pszText, CREATE_SUSPENDED,&nID);   //最后一个0就是立即启动
    //如果想让子线程执行，就不能让主线程结束
    getchar();

    return 0;
}
~~~

如果执行回车对调线程1和线程2的状态，则可以

~~~c++
#include <windows.h>
#include "stdio.h"

DWORD CALLBACK TestProc(LPVOID pParam){
    char * pszText = (char *)pParam;

    while(1){
        printf("%s\n", pszText);
        Sleep(1000);
    }
}
DWORD CALLBACK TestProc2(LPVOID pParam){
    char * pszText2 = (char *)pParam;

    while(1){
        printf("%s\n", pszText2);
        Sleep(1000);
    }
}

int main(){

    DWORD nID = 0;
    char * pszText = "********";
    HANDLE p1 =  CreateThread(NULL, 0, TestProc, pszText, 0,&nID);   //最后一个0就是立即启动

    char * pszText2 = "---------";//CREATE_SUSPENDED
    HANDLE p2 =  CreateThread(NULL, 0, TestProc2, pszText2, CREATE_SUSPENDED,&nID);   //最后一个0就是立即启动

    getchar();

    SuspendThread(p1);
    ResumeThread(p2);

    getchar();
    

    return 0;
}
~~~

![caa2e27a803b13902166b7895e516756.png](https://s1.imagehub.cc/images/2023/03/19/caa2e27a803b13902166b7895e516756.png)

现在我们是只执行线程1，我们回车，就会只打印线程2

![be7d2e4eb4cfc71c89d0bdae79d5f94f.png](https://s1.imagehub.cc/images/2023/03/19/be7d2e4eb4cfc71c89d0bdae79d5f94f.png)

线程关闭

第二个（结束函数所在的线程），谁调谁死

![3b7641524c1fb1013292fadf2a96ab07.png](https://s1.imagehub.cc/images/2023/03/19/3b7641524c1fb1013292fadf2a96ab07.png)



![034bedfd88ab901544746ad92d96bc01.png](https://s1.imagehub.cc/images/2023/03/19/034bedfd88ab901544746ad92d96bc01.png)

当前程序实例句柄，窗口句柄，菜单句柄，图标光标句柄，线程句柄

线程句柄具有有信号和无信号两种状态（必须是可等候句柄，例如线程句柄，互斥句柄，事件句柄，信号量句柄）

![f189b354d550345b020761b4a4f0008d.png](https://s1.imagehub.cc/images/2023/03/19/f189b354d550345b020761b4a4f0008d.png)

线程什么时候有信号？

当线程处于执行状态时，无信号

执行完成之后，有信号





#### 线程同步

当多个线程同步操作一个临界资源时

原子锁

原子操作：运算符操作[比如加加运算]

![5da545c7dc72a5c801fcc555ff6fd2cb.png](https://s1.imagehub.cc/images/2023/03/19/5da545c7dc72a5c801fcc555ff6fd2cb.png)

~~~c++
#include <windows.h>
#include "stdio.h"

long g_value = 0;
DWORD CALLBACK TestProc1(LPVOID pParam){
    for (int i = 0; i < 10000; ++i) {
        g_value++;
    }
    return 0;
}
DWORD CALLBACK TestProc2(LPVOID pParam){
    for (int i = 0; i < 10000; ++i) {
        g_value++;
    }
    return 0;
}

int main(){

    DWORD nID = 0;

    HANDLE hThread[2];

    hThread[0] = CreateThread(NULL, 0, TestProc1, NULL, 0, &nID);
    hThread[1] = CreateThread(NULL, 0, TestProc2, NULL, 0, &nID);

    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
    printf("%d\n",g_value);

    return 0;
}
~~~

刚好循环结束输出20000

[![ppYzS9H.png](https://s1.ax1x.com/2023/03/19/ppYzS9H.png)](https://imgse.com/i/ppYzS9H)

这里我们增大数量为1百万

[![ppYzEE8.png](https://s1.ax1x.com/2023/03/19/ppYzEE8.png)](https://imgse.com/i/ppYzEE8)

导致精度丢失

导致这种问题出现的原因就是我们对加1操作的不规范

![a950b9027fadb29139bc7dc628442f21.png](https://s1.imagehub.cc/images/2023/03/19/a950b9027fadb29139bc7dc628442f21.png)

这里当我们执行完

~~~
eax = g_value;
eax = eax + 1;
~~~

之后，如果cpu执行这个的时间到了，就会把这个线程保护起来，然后执行其他线程

~~~
右侧的三个都执行完后g_value = 1
~~~

再回到左边执行g_value = eax;

最后g_value == 1，而不是2，这样精度就丢失了

修复：

利用原子锁直接操作内存

~~~c++
InterLockedIncrement(&g_value);
~~~

~~~c++
#include <windows.h>
#include "stdio.h"

long g_value = 0;
DWORD CALLBACK TestProc1(LPVOID pParam){
    for (int i = 0; i < 1000000; ++i) {
        InterlockedIncrement(&g_value);
    }
    return 0;
}
DWORD CALLBACK TestProc2(LPVOID pParam){
    for (int i = 0; i < 1000000; ++i) {
        InterlockedIncrement(&g_value);
    }
    return 0;
}

int main(){

    DWORD nID = 0;

    HANDLE hThread[2];

    hThread[0] = CreateThread(NULL, 0, TestProc1, NULL, 0, &nID);
    hThread[1] = CreateThread(NULL, 0, TestProc2, NULL, 0, &nID);

    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
    printf("%d\n",g_value);

    return 0;
}
~~~

![e470b0fd0c4351f8530fc7149479885b.png](https://s1.imagehub.cc/images/2023/03/19/e470b0fd0c4351f8530fc7149479885b.png)

原理：

当一个线程在执行时会上一把锁，当第一个线程执行时，cpu给的时间片到了就会停止

此时因为上锁了，线程2也无法操作该地址

当时间片又分到了线程一，线程一成功执行完后就会解锁，

然后到线程二执行时，线程二也会上一把锁，同理，线程一也无法操作上了锁的地址

=====

以上是++操作，每一种运算都有一种原子锁函数

#### 互斥

原子锁只能对运算符上锁，互斥代码也可以上锁

![](https://s3.bmp.ovh/imgs/2023/03/20/7d5b5e021d985f52.png)

如果bLnitialOwner为true，那么创建互斥的线程拥有互斥，如果为false，则不拥有

当某一个线程拥有互斥则无信号；当任何线程都不拥有互斥，互斥句柄有信号

任何一个时间点只能有一个线程拥有互斥

![](https://s3.bmp.ovh/imgs/2023/03/20/66fa9795316b6335.png)

![](https://s3.bmp.ovh/imgs/2023/03/20/5c3255ccb0df4a5f.png)

~~~c++
#include <windows.h>
#include "stdio.h"

HANDLE g_hMutex = 0;

DWORD CALLBACK TestProc(LPVOID pParam){
    char * pszText = (char *)pParam;

    while(1){
        WaitForSingleObject(g_hMutex, INFINITE);
        for (int i = 0; i < strlen(pszText); ++i) {
            printf("%c", pszText[i]);

            Sleep(125);
        }

        printf("\n");
        ReleaseMutex(g_hMutex);

    }
}
DWORD CALLBACK TestProc2(LPVOID pParam){
    char * pszText2 = (char *)pParam;

    while(1){
        WaitForSingleObject(g_hMutex, INFINITE);
        for (int i = 0; i < strlen(pszText2); ++i) {
            printf("%c", pszText2[i]);

            Sleep(125);
        }

        printf("\n");
        ReleaseMutex(g_hMutex);

    }
}

int main(){

    g_hMutex = CreateMutex(NULL, FALSE, NULL);

    DWORD nID = 0;
    char * pszText = "********";
    HANDLE p1 =  CreateThread(NULL, 0, TestProc, pszText, 0,&nID);   //最后一个0就是立即启动

    char * pszText2 = "---------";//CREATE_SUSPENDED
    HANDLE p2 =  CreateThread(NULL, 0, TestProc2, pszText2, 0,&nID);   //最后一个0就是立即启动

    getchar();



    return 0;
}
~~~

原理：程序刚开始时互斥有信号，线程1发现有信号后执行程序，此时变成无信号，此时如果线程1的时间片到了，轮到线程2来执行，发现此时无信号，则无法执行，等到又到了线程1的时间片，执行完成后变成有信号，此时再由线程2执行



原子锁和互斥实现加锁

事件和信号量实现的是线程间协调工作

![](https://s3.bmp.ovh/imgs/2023/03/20/a1949146b3ec308d.png)

事件句柄也是可等候句柄

![](https://s3.bmp.ovh/imgs/2023/03/20/78c90ca47662834c.png)

![](https://s3.bmp.ovh/imgs/2023/03/20/e17076c56d25e1cc.png)

~~~c++
#include <windows.h>
#include "stdio.h"

HANDLE g_hEvent = 0;

DWORD CALLBACK PrintProc(LPVOID pParam){
    while(1){
        WaitForSingleObject(g_hEvent, INFINITE);
        printf("**********************\n");
        ResetEvent(g_hEvent);
    }
}

DWORD CALLBACK CtrlProc(LPVOID pParam){
    while(1){
        Sleep(1000);
        SetEvent(g_hEvent);
    }
}

int main(){


    g_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    DWORD nID = 0;
    HANDLE hThread[2] = { 0 };
    hThread[0] = CreateThread(NULL, 0, PrintProc, NULL, 0, &nID);
    hThread[1] = CreateThread(NULL, 0, CtrlProc, NULL, 0, &nID);
    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);

    return 0;
}
~~~

##### 死锁

![](https://s3.bmp.ovh/imgs/2023/03/20/0da2e12d658734ab.png)

##### 信号量

![](https://s3.bmp.ovh/imgs/2023/03/20/abb931affd791c11.png)

![](https://s3.bmp.ovh/imgs/2023/03/20/04da24ba9a84a546.png)









~~~c++
#include <windows.h>
#include <iostream>

using namespace std;

int main()
{
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;

    wchar_t* appName = L"C:\\Windows\\System32\\cmd.exe";
    WCHAR* commandLine = "whoami";
    SECURITY_ATTRIBUTES saProcess = { sizeof(SECURITY_ATTRIBUTES) };
    SECURITY_ATTRIBUTES saThread = { sizeof(SECURITY_ATTRIBUTES) };

    BOOL ret = CreateProcess(appName, commandLine, &saProcess, &saThread, FALSE, 0, NULL, NULL, &si, &pi);

    if (!ret)
    {
        cout << "Fail to create process!" << endl;
        return -1;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    return 0;
}
~~~



#### CreateProcess函数

~~~c++
#include <windows.h>

int main() {
    STARTUPINFOA si;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    CreateProcessA("C:\\Windows\\System32\\calc.exe", NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    // C:\Windows\System32\cmd.exe
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/20/ae7b759191d89e48.png)

~~~
1. lpApplicationName：可执行文件的路径或文件名。若为NULL，则使用lpCommandLine中的字符串作为可执行文件名。

例如：

```C++
LPCSTR lpApplicationName = "C:\\Program Files\\Internet Explorer\\iexplore.exe";
```

2. lpCommandLine：命令行参数。如果lpApplicationName为NULL，则该参数必须包含文件名和路径。

例如：

```C++
LPSTR lpCommandLine = "C:\\Program Files\\Internet Explorer\\iexplore.exe http://www.baidu.com";
```

3. lpProcessAttributes：用于指定新进程的安全描述符。通常设置为NULL。

例如：

```C++
LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL;
```

4. lpThreadAttributes：用于指定新线程的安全描述符。通常设置为NULL。

例如：

```C++
LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL;
```

5. bInheritHandles：用于控制子进程是否可以继承父进程的句柄。如果为TRUE，则子进程拥有与父进程相同的句柄；否则，子进程不会继承任何句柄。通常设置为FALSE。

例如：

```C++
BOOL bInheritHandles = FALSE;
```

6. dwCreationFlags：创建进程的标志。常见的标志包括CREATE_NEW_CONSOLE（新建一个控制台窗口）、DETACHED_PROCESS（创建无控制台窗口的进程）等。具体标志可以参考MSDN文档。

例如：

```C++
DWORD dwCreationFlags = CREATE_NEW_CONSOLE;
```

7. lpEnvironment：用于传递环境变量给新进程。通常设置为NULL，表示新进程将继承当前进程的环境变量。

例如：

```C++
LPVOID lpEnvironment = NULL;
```

8. lpCurrentDirectory：用于指定新进程的工作目录。如果为NULL，则使用当前进程的工作目录。

例如：

```C++
LPCSTR lpCurrentDirectory = "C:\\Users\\username\\Desktop";
```

9. lpStartupInfo：指向一个STARTUPINFO结构体，用于指定新进程的一些属性，比如窗口大小、标题等。通常设置为NULL。

例如：

```C++
STARTUPINFOA si;
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);

LPSTARTUPINFOA lpStartupInfo = &si;
```

10. lpProcessInformation：返回新进程和主线程的信息，包括进程和线程的句柄以及标识符。调用者需要负责释放相关资源。
~~~

GetModuleFileName函数

~~~c++
#include <windows.h>
#include <stdio.h>

int main()
{
    TCHAR szPath[MAX_PATH];
    if (GetModuleFileName(NULL, szPath, MAX_PATH))
    {
        printf(("exe path: %s\n"), szPath);
    }
    else
    {
        printf(("failed to get exe path\n"));
    }
    return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/20/4315b776596b0738.png)

#### GetCurrentDirectory函数

~~~c++
#include <iostream>
#include <Windows.h>

int main()
{
    TCHAR buffer[MAX_PATH];
    DWORD length = GetCurrentDirectory(MAX_PATH, buffer);
    std::wcout << L"Current Directory: " << buffer << std::endl;
    return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/20/2836792688ae804f.png)



#### URLDownloadFile函数

文件自动下载

~~~c++
#include <windows.h>
#include <urlmon.h>

#pragma comment(lib, "urlmon.lib")

int main()
{
    HRESULT hr = URLDownloadToFile(NULL, "https://s1.ax1x.com/2023/03/19/ppYzS9H.png", "E:\idm\\image.jpg", 0, NULL);
    if (hr == S_OK) {
        MessageBox(NULL, "文件下载成功！", "提示", MB_OK);
    }
    else {
        MessageBox(NULL, "文件下载失败！", "提示", MB_OK);
    }
    return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/20/93adb65dd76ce50a.png)

![](https://s3.bmp.ovh/imgs/2023/03/20/15ca84d0b6f71b60.png)![](https://s3.bmp.ovh/imgs/2023/03/20/63e76d49454493ba.png)

#### ShellExecuteEx函数

~~~c++
#include <windows.h>
#include <shellapi.h>

int main()
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS; // 等待子进程结束
    sei.lpFile = "calc.exe"; // 打开记事本
//    sei.lpParameters = "test.txt"; // 打开 test.txt 文件
    sei.nShow = SW_SHOWNORMAL; // 显示方式为普通窗口
    if (!ShellExecuteEx(&sei)) {
        MessageBox(NULL, "Failed to open file.", "Error", MB_OK | MB_ICONERROR);
        return -1;
    }

    WaitForSingleObject(sei.hProcess, INFINITE); // 等待记事本程序退出

    return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/20/b6267181ea32c309.png)

.

#### DeleteFile函数



~~~
#include <windows.h>
#include <shellapi.h>

int main()
{
    DeleteFile("E:\\idm\\image.jpg");

    return 0;
}
~~~



#### CopyFile函数

~~~c++
#include <windows.h>
#include <shellapi.h>

int main()
{
    BOOL bRet = CopyFile("E:\\idm\\flag.txt","E:\\idm\\DwnlData\\flag.txt", FALSE);

    if(bRet){
        MessageBox(NULL, "success","123", MB_YESNO);
    }else{
        MessageBox(NULL, "fail","123", MB_YESNO);
    }
    
    return 0;
}
~~~

![](https://s3.bmp.ovh/imgs/2023/03/20/0ec6499039e96749.png)![](https://s3.bmp.ovh/imgs/2023/03/20/af54dba590c71d12.png)

#### MoveFile函数

。。。

#### CreateFile函数

~~~c++
#include <windows.h>
#include <stdio.h>

int main() {
    HANDLE hFile = CreateFile("example123.txt", // 文件名
                              GENERIC_WRITE,                      // 写权限
                              0,                                   // 不共享
                              NULL,                                // 默认安全属性
                              CREATE_ALWAYS,                       // 总是创建新文件
                              FILE_ATTRIBUTE_NORMAL,               // 普通文件属性
                              NULL);                               // 没有模板文件

    if (hFile == INVALID_HANDLE_VALUE)
    {
        // 文件打开或创建失败
    }
    else
    {
        char data[] = "Hello, world!";
        DWORD nBytesWritten;
        BOOL success = WriteFile(hFile, data, sizeof(data), &nBytesWritten, NULL);
        CloseHandle(hFile);

        if (!success)
        {
            // 写入数据失败
        }
        else
        {
            // 写入成功
        }
    }
    return 0;
}
~~~

#### GetFileSize函数












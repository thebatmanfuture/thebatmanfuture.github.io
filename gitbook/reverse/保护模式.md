##### 1.保护模式-理解内核

x86 CPU的三个模式：实模式，保护模式，虚模式

特点：段的机制和页的机制

正常情况下，我们想读某一个进程的内存，需要操作系统的api函数（写应用层调用ring3的api，写驱动调用ring0的api）

利用保护模式，不需要操作系统的api函数

##### 2.段寄存器结构

![](https://s3.bmp.ovh/imgs/2023/05/06/db5baace26c9a6f3.png)

![](https://s3.bmp.ovh/imgs/2023/05/06/6db64aad9f5b758e.png)

这里我们的段寄存器是96位的，可见部分是右边的16位，即

![imageadbd5f9f8ebda9d3.png](https://s1.imagehub.cc/images/2023/05/06/imageadbd5f9f8ebda9d3.png)

~~~
16位的可见部分
16位的属性：表示当前的寄存器是可读的还是可写的，或者是可执行的
32位的base：指的是当前这个段是从哪里开始的
32位的Limit：指的是当前这个段的长度是多少
~~~

我们通过

~~~
MOV AX,ES
MOV DS,AX
~~~

读一个寄存器时是读16位，写的时候是写96位

问题一：段寄存器只能看到16位，如何证明有96位？

问题二：写段寄存器时，只给了16位了，那剩下的80应该填什么？



##### 3.段寄存器属性探测

[![p96M6it.png](https://s1.ax1x.com/2023/05/13/p96M6it.png)](https://imgse.com/i/p96M6it)

![imagefe371ccd86f0bb8b.png](https://s1.imagehub.cc/images/2023/05/06/imagefe371ccd86f0bb8b.png)

~~~c
#include "stdlib.h"
#include "stdio.h"
#include "windows.h"
int var = 0;
int main() {
    __asm
    {
        mov ax, ss
        mov ds, ax
        mov dword ptr ds : [var] , eax
    }
    return 0;
}
~~~

可读是指这里的：SS，可写：dword ptr ds : [var]

可执行：当前修饰的地址可以赋值给eip

编译链接这段代码并没有报错，因为ss寄存器和ds寄存器都是可读可写，属性一样

但是如果我们把ss替换成cs，那么熟悉不匹配编译链接就会报错

![image42a2c30597e9f57e.png](https://s1.imagehub.cc/images/2023/05/06/image42a2c30597e9f57e.png)![image4919b822d57d5823.png](https://s1.imagehub.cc/images/2023/05/06/image4919b822d57d5823.png)

~~~c
#include "stdlib.h"
#include "stdio.h"
#include "windows.h"


int var = 0;
int main() {
    __asm
    {
        mov ax, fs
        mov gs,ax
        mov eax,gs:[0]
        // mov
        mov dword ptr ds:[var],eax
    }
    return 0;
}
~~~

这里[0]，0地址是不能读，也不能写的

这里实际就是fs.base + 0

![image92b7624a50296627.png](https://s1.imagehub.cc/images/2023/05/06/image92b7624a50296627.png)

~~~c
#include "stdlib.h"
#include "stdio.h"
#include "windows.h"


int var = 0;
int main() {
    __asm
    {
        mov ax, fs
        mov gs,ax
        mov eax,gs:[0x1000]
        // mov
        mov dword ptr ds:[var],eax
    }
    return 0;
}
~~~

这里因为[0x1000]大于0xFFF越界了，所以无法编译链接



##### 4.段描述符与段选择子

查表查的就是GDT这张表

![imagee3e8306975a2573c.png](https://s1.imagehub.cc/images/2023/05/06/imagee3e8306975a2573c.png)

gdtr这个寄存器存了两个值，一个是gdt这张表在哪里（开始位置），还有一张就是这张表有多大

~~~
r gdtr就是看gdt这张表在哪里
r gdtl就是看gdt的表多大
dd 8003f000就是查看这个内存地址，或者说就是查看gdt这张表的数据
~~~

![image.png](https://s1.imagehub.cc/images/2023/05/07/image.png)

后面这四个就是里面的数据

gdt里面存储的每一个元素都叫段描述符（8个字节）

![image4c42cafe6611fe60.png](https://s1.imagehub.cc/images/2023/05/07/image4c42cafe6611fe60.png)

段描述符

![image740b459406ee6b73.png](https://s1.imagehub.cc/images/2023/05/07/image740b459406ee6b73.png)

~~~
dd是d dword 即每四个字节分一组，而
dq是d qword，即每八个字节分一组
~~~

![](https://s3.bmp.ovh/imgs/2023/05/07/674ca83120398bd0.png)

如图，左边是段描述符的8个字节，上面是高4字节，下面是第四字节，正好对应了右下角指向，而高4个字节对应的是前面的值，也就是我们通过dq查看某个地址的内存时，高位在前，低位在后

![](https://s3.bmp.ovh/imgs/2023/05/07/9018466736edf702.png)

~~~
#	我们可以输入dq xxxx L40就是显示40组
dq 8003f000 L40
~~~

![](https://s3.bmp.ovh/imgs/2023/05/07/e58934f673247a78.png)

当我们通过mov指令执行时，实际上就是查找gpt表，查什么位置由ax决定，如果查到了，会把查出来的段描述符取出来，放在段寄存器里

~~~
mov ds,ax
~~~

![](https://s3.bmp.ovh/imgs/2023/05/07/b241575db7f161c1.png)

段选择子是一个16位的段描述符，这个决定了我在gpt表里查哪一个段描述符

例如，我们段选择子是1B => 001B => 0000 0000 0001 1011

那么1011里面的11就是 RPL，而0就是我要差的是GPT表，而不是LDT表（该表在win中不用），剩下的内容是：3

~~~
0000 0000 0001 1
~~~

![](https://s3.bmp.ovh/imgs/2023/05/07/6153393de4433b73.png)

这里就取这个3，所以当我给段选择子是1B时，它的段描述符就是这个3

这里我们先定义一个地址，里面存了6个字节的数，fword是6个字节，qword是8个字节，dword是4个字节

如下代码的含义是，从buffer这个指令，取出高2字节作为段描述子给es，取出低4字节给ecx

~~~assembly
les ecx,fword ptr ds:[buffer]
~~~



![](https://s3.bmp.ovh/imgs/2023/05/07/141f6a2f2b0b80fe.png)

问题：

段寄存器有96位，有16位是公开对外访问的（段选择子），段描述符有64位（8个字节，每个字节8位），被加载到段寄存器里，那么剩下的呢

##### 5.段描述符的属性_ P位 _G位

P位位于高4个字节的第15个位置，G位位于高4个字节的23个位置，

![](https://s3.bmp.ovh/imgs/2023/05/07/0fea691c1b304f55.png)

P位，当我们通过指令将段描述符加载到段寄存器，CPU首先检测P位是0还是1，是否是有效的，有效才做后续检查

![](https://s3.bmp.ovh/imgs/2023/05/07/e2043a96dd125ffd.png)

如图，前16位Selector对外公开的就是段选择子，而Atrribute这个属性是16位的，对应的是段描述符的高4字节从8位到23位

![](https://s3.bmp.ovh/imgs/2023/05/07/a71972f723eb38d9.png)

而Base由三部分组成

1）高4字节的，24-31位

2）高4字节的，0-7位

3）低4字节的16-31位 

![](https://s3.bmp.ovh/imgs/2023/05/07/7c53ac3ce15396bb.png)

而Limit有两部分组成：

1）高4字节，16-19位

2）低4字节，0-15位

这样加起来也就是20位，最大能表示FFFFF（0x），不到32位

当高4字节的23位为0时，意味着是字节，就是000 FFFFF，最大值就是5个F

当G位为1时，Limit单位是4KB，就相当于是1FFF，FFFFF FFF

![](https://s3.bmp.ovh/imgs/2023/05/07/40d60fff5a8be932.png)

##### 6.段描述符的属性_ S位 _Type位

S位是高4字节的第12位,Type是高4字节的8-11位

当S位为1时，可能是代码段描述符或者数据段描述符

当S位为1时，是系统段描述符

![](https://s3.bmp.ovh/imgs/2023/05/07/ab16e523964ad977.png)

只有当S位先判断完才能看Type位

上图是数据段，下图是代码段

![](https://s3.bmp.ovh/imgs/2023/05/07/83ef1f4801500d1e.png)

DPL（13，14位）在windows里或者都是0或者都是1

正常情况下当P是1，S是1，而DPL是00时，那就是1001，就是9，如果是11，那就是1111，那就是F

![](https://s3.bmp.ovh/imgs/2023/05/07/7c53ac3ce15396bb.png)

所以我只要分析它的第五位如果是9或者F，那就是代码段或者数据段![](https://s3.bmp.ovh/imgs/2023/05/07/6b9d214ed5ae8dde.png)

当我们已经确认是代码段或数据段时就看type域的第11位，如果是0就是数据段，如果是1就是代码段，例如

~~~
00cf9b00	// 这里9b和fb，这里b是大于8的，也就是第11位为1，所以是代码段
00cffb00	// 
~~~

这里第8位A是是否访问过的意思，比如操作系统在启动的时候段描述符是没有被加载过的，所以A一定是0，当被访问过了，那么第8位会被置1

第9位就是判断是否可写

第10位，当为0时，是向上拓展，当为1时是向下拓展

如图，fs.base表示是从哪里开始

~~~
向上拓展：左图，从base到limit是有效位置
向下拓展：右图，从base到limit就不能是有效地址，而是反向位置
~~~



![](https://s3.bmp.ovh/imgs/2023/05/07/be25f13e91dc9529.png)

以上是数据段，如果是代码段

![](https://s3.bmp.ovh/imgs/2023/05/07/230cab7095e95f57.png)![](https://s3.bmp.ovh/imgs/2023/05/07/9ec4a246c2ad7ac0.png)

A位的含义都是一样的，表示当前这个段是否被访问过，R位是可读位，是否可读，C是一致位，当C = 1时是一致代码段，当C = 0时是非一致代码段



当我们的S是0时，是系统段描述符

![](https://s3.bmp.ovh/imgs/2023/05/07/98906440afa7e176.png)

![](https://s3.bmp.ovh/imgs/2023/05/07/53ee4d5997d6ed29.png)

##### 7.段描述符的属性_ DB位

DB位是第22位，

![](https://s3.bmp.ovh/imgs/2023/05/07/fb45acfaf1a03f91.png)

[![p96lejU.png](https://s1.ax1x.com/2023/05/13/p96lejU.png)](https://imgse.com/i/p96lejU)

![image5d6231ffec9739eb.png](https://s1.imagehub.cc/images/2023/05/07/image5d6231ffec9739eb.png)

[![p9DfoXF.png](https://s1.ax1x.com/2023/05/10/p9DfoXF.png)](https://imgse.com/i/p9DfoXF)

##### 8.段权限检查

我们通常所说应用程序为3环【我们写的】，系统程序是0环【驱动/内核程序】

[![p9DfOt1.png](https://s1.ax1x.com/2023/05/10/p9DfOt1.png)](https://imgse.com/i/p9DfOt1)

[![p9DhSXD.png](https://s1.ax1x.com/2023/05/10/p9DhSXD.png)](https://imgse.com/i/p9DhSXD)

CS寄存器的后两位称为特权级别，叫CPL，例如

CS 001B，这里的1B就是0001 1011，最后两位就是3，所以是ring3

[![p9DhmjS.png](https://s1.ax1x.com/2023/05/10/p9DhmjS.png)](https://imgse.com/i/p9DhmjS)

如图，8就是1000，是ring0

[![p9Dh3hq.png](https://s1.ax1x.com/2023/05/10/p9Dh3hq.png)](https://imgse.com/i/p9Dh3hq)

如图，是DPL

[![p9DhUuF.png](https://s1.ax1x.com/2023/05/10/p9DhUuF.png)](https://imgse.com/i/p9DhUuF)

[![p9DhBNR.png](https://s1.ax1x.com/2023/05/10/p9DhBNR.png)](https://imgse.com/i/p9DhBNR)

总结：

CPL：当我把一个exe拖进xbg，CS寄存器的后两位称为特权级别

DPL：说白了就是描述符的特权级别，规定了访问这个段你所需要的权限，权限不够就不让访问

~~~
mov ds,ax // 如果ax指向的段DPL=0，但是当前的应用程序只是DPL=3，那么没有权限访问
~~~

RPL：针对段选择子的，每个段的选择子都有这个，

[![p9D4XQK.png](https://s1.ax1x.com/2023/05/10/p9D4XQK.png)](https://imgse.com/i/p9D4XQK)

[![p9D5pod.png](https://s1.ax1x.com/2023/05/10/p9D5pod.png)](https://imgse.com/i/p9D5pod)

##### 9.代码跨段执行

[![p9D5ak9.png](https://s1.ax1x.com/2023/05/10/p9D5ak9.png)](https://imgse.com/i/p9D5ak9)

[![p96lbKU.png](https://s1.ax1x.com/2023/05/13/p96lbKU.png)](https://imgse.com/i/p96lbKU)

[![p96lLb4.png](https://s1.ax1x.com/2023/05/13/p96lLb4.png)](https://imgse.com/i/p96lLb4)

[![p9619xK.png](https://s1.ax1x.com/2023/05/13/p9619xK.png)](https://imgse.com/i/p9619xK)

[![p961dMT.png](https://s1.ax1x.com/2023/05/13/p961dMT.png)](https://imgse.com/i/p961dMT)

~~~
操作系统提供了一段代码，这些代码提供一些通用的功能，这些功能不会对系统的内核数据进行破坏，我希望这些功能可以被应用层直接访问，则用一致代码段。
~~~

[![p9617FA.png](https://s1.ax1x.com/2023/05/13/p9617FA.png)](https://imgse.com/i/p9617FA)

[![p961bWt.png](https://s1.ax1x.com/2023/05/13/p961bWt.png)](https://imgse.com/i/p961bWt)

简单来说，对于一致代码段，就是CPU的内核级给用户层低权限直接调用到，这不会对内核层造成破坏

[![p961xeg.png](https://s1.ax1x.com/2023/05/13/p961xeg.png)](https://imgse.com/i/p961xeg)

##### 10.代码跨段跳转-修改CS寄存器

[![p963Soj.png](https://s1.ax1x.com/2023/05/13/p963Soj.png)](https://imgse.com/i/p963Soj)

[![p963PWq.png](https://s1.ax1x.com/2023/05/13/p963PWq.png)](https://imgse.com/i/p963PWq)

~~~
 jmp 0x20,0x004 183D7
~~~

[![p963Whn.png](https://s1.ax1x.com/2023/05/13/p963Whn.png)](https://imgse.com/i/p963Whn)

[![p963TnU.png](https://s1.ax1x.com/2023/05/13/p963TnU.png)](https://imgse.com/i/p963TnU)

假如我们的CPL的是ring3，但是我们一定要访问一个ring0的代码段，我们就可以利用调用门来提权

##### 11.长调用和短调用

[![p96Gwsf.png](https://s1.ax1x.com/2023/05/13/p96Gwsf.png)](https://imgse.com/i/p96Gwsf)

[![p96Grdg.png](https://s1.ax1x.com/2023/05/13/p96Grdg.png)](https://imgse.com/i/p96Grdg)

长调用分为两种：跨段不提权和跨段提权

前者就是ring3跨段跳到ring3，后者就是ring3到ring0



[![p96Jdh9.png](https://s1.ax1x.com/2023/05/13/p96Jdh9.png)](https://imgse.com/i/p96Jdh9)

[![p96JOhj.png](https://s1.ax1x.com/2023/05/13/p96JOhj.png)](https://imgse.com/i/p96JOhj)

[![p96YpuV.png](https://s1.ax1x.com/2023/05/13/p96YpuV.png)](https://imgse.com/i/p96YpuV)

[![p96YCHU.png](https://s1.ax1x.com/2023/05/13/p96YCHU.png)](https://imgse.com/i/p96YCHU)

##### 12.调用门

[![p96YEC9.png](https://s1.ax1x.com/2023/05/13/p96YEC9.png)](https://imgse.com/i/p96YEC9)

[![p96YuDK.png](https://s1.ax1x.com/2023/05/13/p96YuDK.png)](https://imgse.com/i/p96YuDK)

门描述符是系统描述符的一类，当S位为0，且type为1100时，就是门描述符

在低32位的16-31位的Segment Selector这个选择子就是你真正要调用的代码，存在哪个段



如下这两段组成了一个地址（高4位的16-31，低4位的0-15）

[![p96YNKP.png](https://s1.ax1x.com/2023/05/13/p96YNKP.png)](https://imgse.com/i/p96YNKP)

总结：

当我们执行call cs:eip时（eip是废弃的），真正要执行的是cs的base + 偏移地址

也就是上图中的segment selector + 两段 offset in segment

我们尝试构造

~~~
// 由于我们暂时不知道跳转到哪，所以前四个为0，p位用来表示当前的段描述符是否有效，所以必须是1，DPL设置成11，S位为0是系统段，type位为1100就是调用门，且我们不需要参数，所以最后是00
~~~

[![p96tLSs.png](https://s1.ax1x.com/2023/05/13/p96tLSs.png)](https://imgse.com/i/p96tLSs)

.

~~~c++
#include <Windows.h>
#include <stdio.h>

 __declspec(naked) void callGate(){
         _asm{
                 int 3                                //软中断
                 retf                                //注意这里长调用对应长返回
         }
 }

int main(){

        char buff[6];
        //*(DWORD*)&buff[0]= 0x12345678;        //低地址32位为0x12345678，EIP已废弃，故随便填即可
        //*(DWORD*)&buff[4]=0x48;                        //高地址16位为0x48，段选择子

        //也可以换作这种写法
        _asm{
                mov dword ptr ds:[buff],0x12345678        //低32位赋值废弃EIP
                lea eax,dword ptr ds:[buff]                        //将buff地址给EAX
                add eax,4                                                        //地址+4，即得到高地址
                mov word ptr ds:[eax],0x48                        //高16位赋值段选择子selector
        }

        //使用 调用门
        _asm{
                call fword ptr ds:[buff]                        //fword 数据宽度为6字节
        }
        return 0;
}
~~~

##### 13.调用门-有参

[![p96dIjs.png](https://s1.ax1x.com/2023/05/13/p96dIjs.png)](https://imgse.com/i/p96dIjs)

[![p96dLNT.png](https://s1.ax1x.com/2023/05/13/p96dLNT.png)](https://imgse.com/i/p96dLNT)

##### 14.中断门

windows没有使用调用门，使用了中断门

1：系统调用

2：调试

可以通过中断门使得从ring3到ring0，或者快速调用，F12就是把下断点的地方改成了0xCC，对应的硬编码指令是int3，就是用来执行中断门的

[![p96wk4O.png](https://s1.ax1x.com/2023/05/13/p96wk4O.png)](https://imgse.com/i/p96wk4O)

调用门的一个call指令就是查表，查GDT表；中断门查的是IDT表（中断描述符表）

[![p96wZgH.png](https://s1.ax1x.com/2023/05/13/p96wZgH.png)](https://imgse.com/i/p96wZgH)

中断门是不可以传参数的，所以高4字节的0-4不可以赋值， DPL是11，如果8-12是1110，是中断门

[![p96wuDI.png](https://s1.ax1x.com/2023/05/13/p96wuDI.png)](https://imgse.com/i/p96wuDI)

##### 15.陷阱门

![imagef909f6919bc94c76.png](https://s1.imagehub.cc/images/2023/05/13/imagef909f6919bc94c76.png)

 中断分为可屏蔽中断（比如锁屏）和不可屏蔽的中断

可屏蔽中断收到IF位影响，如果此时为0，那么你摁键盘无响应

不可频闭中断，比如断电，一旦发生，不管IF位是1还是0，CPU立即处理

![image944ae2a7e2365f1c.png](https://s1.imagehub.cc/images/2023/05/13/image944ae2a7e2365f1c.png)

##### 16.任务段

![image170e5b3042f2f8c8.png](https://s1.imagehub.cc/images/2023/05/13/image170e5b3042f2f8c8.png)

![image-20230513144707916](C:\Users\batma\AppData\Roaming\Typora\typora-user-images\image-20230513144707916.png)

TSS不在CPU中，在内存中

![image8be845af9945fdc5.png](https://s1.imagehub.cc/images/2023/05/13/image8be845af9945fdc5.png)

英特尔本来使用TSS来实现任务的切换，本阶段想象中切换寄存器就好了

![image2ac01080ce879c5b.png](https://s1.imagehub.cc/images/2023/05/13/image2ac01080ce879c5b.png)

![imagec91a03d90ee8669d.png](https://s1.imagehub.cc/images/2023/05/13/imagec91a03d90ee8669d.png)

TR里面的值是从GDT表中的段描述符加载进去的

![image134690ab3c4ee076.png](https://s1.imagehub.cc/images/2023/05/13/image134690ab3c4ee076.png)

![imagea8c7e3b14c96965d.png](https://s1.imagehub.cc/images/2023/05/13/imagea8c7e3b14c96965d.png)



##### 18.任务门

![image.png](https://cdnjson.com/images/2023/05/13/image.png)

![imagea9ed2b3408e9e1a6.png](https://cdnjson.com/images/2023/05/13/imagea9ed2b3408e9e1a6.png)

##### 19.分页的机制




























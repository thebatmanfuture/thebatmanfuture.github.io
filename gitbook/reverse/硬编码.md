#### 1.硬编码

[![ppNUrfx.png](https://s1.ax1x.com/2023/03/20/ppNUrfx.png)](https://imgse.com/i/ppNUrfx)

指令最长15字节，最短1字节

[![ppNU4AA.png](https://s1.ax1x.com/2023/03/20/ppNU4AA.png)](https://imgse.com/i/ppNU4AA)

~~~
病毒与反病毒：shellcode 特征码
加密与解密： 指令壳 VMP
外挂和反外挂：HOOK 提串
~~~





#### 2.前缀指令

前缀指令很少就几个，在反汇编工具中标记了：前的值是前缀质量，后面就是Opcode

[![ppNaY4I.png](https://s1.ax1x.com/2023/03/20/ppNaY4I.png)](https://imgse.com/i/ppNaY4I)

前缀指令分组

<1>

前缀指令每组最多1个，总共最多4个

[![ppNaNCt.png](https://s1.ax1x.com/2023/03/20/ppNaNCt.png)](https://imgse.com/i/ppNaNCt)

LOCK是用来锁地址总线的，比如在这行指令前加上LOCK的话，那么当前这个地址如果有多个CPU，那么在某一时刻只能有一个CPU可以读这个地址【多核下】

[![ppNaagf.png](https://s1.ax1x.com/2023/03/20/ppNaagf.png)](https://imgse.com/i/ppNaagf)



REPNE/REPNZ 和 REP/REPZ这两个都是重复执行后面的指令

<2>段前缀指令：告诉CPU使用的是哪一个段

当我们在读取内存时没有特殊提示等，默认用DS寄存器，如果有EBP或者ESP时，默认是SS

[![ppNa280.png](https://s1.ax1x.com/2023/03/20/ppNa280.png)](https://imgse.com/i/ppNa280)

作用就是改变默认的寄存器是谁

[![ppNajKO.png](https://s1.ax1x.com/2023/03/20/ppNajKO.png)](https://imgse.com/i/ppNajKO)

如何判断当前CPU是16位还是32位，默认情况下就是看当前CS寄存器的DB位，如果DB位是1就是32位，如果是0就是16位

当前也可以通过前缀指令实现在32位CPU下使用16位的指令，只需要在指令前加上

66：55，这个66指令就是用来改变操作数的默认宽度

[![ppNddiR.png](https://s1.ax1x.com/2023/03/20/ppNddiR.png)](https://imgse.com/i/ppNddiR)

<4>地址宽度前缀指令

同样的，当CS寄存器的db位为1时，处于32位模式，采用的寻址方式都是按照32位寻址进行的，67是用来改变寻址方式的

[![p9a0y1f.png](https://s1.ax1x.com/2023/05/06/p9a0y1f.png)](https://imgse.com/i/p9a0y1f)

#### 3.定长指令与变长指令

​	Opcode最少一个字节，最多三个字节

由ModR/M一定是变长的，没有就一定是定长的

![ppNUrfx.png](https://s1.ax1x.com/2023/03/20/ppNUrfx.png)

opcode + modR/M + SIB三个组合决定了长度是多少，而Displacement和Immdeiate是由前三个决定的，当这三个决定之后，后两个也就确定了

modR/M有没有由opcode决定，SIB有没有由modR/M决定

定长指令，像如下这种53 56 57 50，只要opcode出现这些，那么指令长度已经确定了，1个字节；

相反，如果是00，那么在不同的情况下可能不同，而这种就是变长指令

[![ppNwiTJ.png](https://s1.ax1x.com/2023/03/20/ppNwiTJ.png)](https://imgse.com/i/ppNwiTJ)

在英特尔白皮书如何区分定长和变长？

1）表格法

像如下00这种是变长，像50这种rAX是定长

2）Zz表示法

[![ppNwZSx.png](https://s1.ax1x.com/2023/03/20/ppNwZSx.png)](https://imgse.com/i/ppNwZSx)

[![ppNwm6K.png](https://s1.ax1x.com/2023/03/20/ppNwm6K.png)](https://imgse.com/i/ppNwm6K)

看到E或者G都是ModR/M

#### 4.定长指令_修改ERX

###### 1.push和pop

~~~
50	push eax
51	push ecx
52	push edx
53	push ebx
54	push esp
55	push ebp
56	push esi
57	push edi
~~~



~~~
58	pop eax
59	pop ecx
5a	pop edx
5b	pop ebx
5c	pop esp
5d	pop ebp
5e	pop esi
5f	pop edi
~~~

###### 2.inc和dec

~~~
40 inc eax	
~~~

[![p9aDOYR.png](https://s1.ax1x.com/2023/05/06/p9aDOYR.png)](https://imgse.com/i/p9aDOYR)



~~~
48 dec eax
~~~

[![p9aDz6K.png](https://s1.ax1x.com/2023/05/06/p9aDz6K.png)](https://imgse.com/i/p9aDz6K)[![p9arSOO.png](https://s1.ax1x.com/2023/05/06/p9arSOO.png)](https://imgse.com/i/p9arSOO)

###### 3.mov

~~~
B0 00 mov al,00
B1 00 mov cl,00
~~~

一旦opcode确定了，长度就确定了

~~~
B8 00 mov eax,00
~~~

[![p9arhAH.png](https://s1.ax1x.com/2023/05/06/p9arhAH.png)](https://imgse.com/i/p9arhAH)



###### 5.xchg

~~~
91 xchg eax, ecx
~~~

这里90是

~~~
xchg eax,eax
就是eax和eax交换，没有意义，所以
90 NOP
~~~

可以通过NOP指令构造花指令，比如这里，E8是我们jmp要跳转的地址，而前面的E7是NOP空指令

[![p9asn81.png](https://s1.ax1x.com/2023/05/06/p9asn81.png)](https://imgse.com/i/p9asn81)

那么我们可以修改NOP这里的90为B0，那么B0 00就会组合在一起，打乱下面的布局，这样别人在跳转的时候发现E8不见了，被藏起来了，它只能通过把B0改成空指令才能让E8出现

[![p9as8Ve.png](https://s1.ax1x.com/2023/05/06/p9as8Ve.png)](https://imgse.com/i/p9as8Ve)

如果在白皮书上发现有硬编码上写了d64，表示操作数宽度是64（默认），且不能为32位



#### 5.定长指令_修改EIP汇总

这里我们的JCC指令70 8B可以向前跳或者向后跳

![](https://s3.bmp.ovh/imgs/2023/05/06/dbc94ed51128b987.png)

![](https://s3.bmp.ovh/imgs/2023/05/06/78d9e6e91fd2538c.png)

那么最大能跳转的就是FF，此时硬编码为70，是2个字节

当跳转的硬编码为0F80时，变成了6个字节

![](https://s3.bmp.ovh/imgs/2023/05/06/23e198120dd7b7bd.png)



![](https://s3.bmp.ovh/imgs/2023/05/06/ae516227569ba955.png)

![](https://s3.bmp.ovh/imgs/2023/05/06/c3aa2a57fad3744f.png)

从EF到F9就是8个字节

F9 - EF - 2字节 = 8字节

![](https://s3.bmp.ovh/imgs/2023/05/06/1a687bbeb4d23a14.png)

这里，先对ECX减一，减完之后如果不等于0时则跳

![](https://s3.bmp.ovh/imgs/2023/05/06/7ec6358dd37fc73c.png)



![](https://s3.bmp.ovh/imgs/2023/05/06/b788d154dbdde414.png)



#### 6.变长指令_ModR/M

ModR/M是一个字节

![](https://s3.bmp.ovh/imgs/2023/05/06/f2973025d0a44200.png)

0，1，2是R/M

2，3，4，5是Reg/Opcode

6，7是Mod

这几个指令是操作内存和寄存器

![](https://s3.bmp.ovh/imgs/2023/05/06/09e2d405bc8dbc44.png)



![](https://s3.bmp.ovh/imgs/2023/05/06/2779fc3e4f872ba2.png)

![](https://s3.bmp.ovh/imgs/2023/05/06/2db6b65b2980403f.png)

比如我们输入88 01，发现查表时发现是变长，MOV Eb, Gb，那么01就是00 000 001

这里00是Mod，000决定是是哪个寄存器，看表发现有32位的EAX和8位的AL，因为是b，所以是AL

所以就是

~~~
MOV EB,AL
~~~

Mod是00，R/M是001就查下面这张表

![](https://s3.bmp.ovh/imgs/2023/05/06/7c0f377166506a32.png)

![](https://s3.bmp.ovh/imgs/2023/05/06/51d26f40b5d43f32.png)

就是ECX，所以88 01就是MOV byte ptr ds:[ecx],al

![](https://s3.bmp.ovh/imgs/2023/05/06/4026d8a17f3bed64.png)





![](https://s3.bmp.ovh/imgs/2023/05/06/a8bb7633d4b1b343.png)

#### 7.变长指令_RegOpcode

![](https://s3.bmp.ovh/imgs/2023/05/06/01a0b13ee13d07e9.png)

![](https://s3.bmp.ovh/imgs/2023/05/06/838da6ea1015786f.png)











